var tipuesearch = {"pages":[{"title":" fortran-s3-accessor ","text":"fortran-s3-accessor Brief description fortran-s3-accessor provides a simple, direct interface for accessing S3-compatible object storage from Fortran programs. The library is designed for scientific computing workflows that need to read and write data to cloud object storage with minimal friction. Key Features Direct HTTP-based S3 operations : GET, PUT, DELETE, and HEAD requests via curl Dual interface design : Low-level s3_http module for direct S3 operations High-level s3_io module providing familiar Fortran I/O patterns (open/read/write/close) URI support : Work with s3://bucket/key URIs for seamless cross-bucket operations Public bucket access : Read from public S3 buckets without authentication Comprehensive testing : Mock-based testing framework with 22+ test cases Zero dependencies : Uses only standard Fortran 2008 and system curl Production ready : Designed for integration with scientific computing workflows (FESOM, climate models, etc.) Architecture The library follows a layered architecture with two main modules: Core Module: s3_http Provides direct curl-based HTTP access to S3 operations: s3_config : Configuration type containing bucket name, region, endpoint, credentials, and protocol settings s3_init(config) : Initialize the library with an S3 configuration s3_get_object(key, content) : Download object content from S3 s3_put_object(key, content) : Upload object content to S3 (requires authentication) s3_object_exists(key) : Check if an object exists using HTTP HEAD requests s3_delete_object(key) : Delete an object from S3 (requires authentication) URI-based Operations For convenience, the library provides URI-aware versions of all operations: s3_get_uri(uri, content) : Get object using s3://bucket/key format s3_put_uri(uri, content) : Put object using URI s3_exists_uri(uri) : Check existence using URI s3_delete_uri(uri) : Delete object using URI These functions automatically parse the bucket name from the URI and temporarily switch contexts when accessing different buckets. High-level Module: s3_io Provides Fortran-like I/O interface built on top of s3_http : s3_open(unit, key, mode, iostat) : Open an S3 object for reading or writing s3_close(unit, iostat) : Close the S3 object (uploads on write mode) s3_read_line(unit, line, iostat) : Read a line from the object s3_write_line(unit, line, iostat) : Write a line to the object buffer s3_rewind(unit, iostat) : Rewind read position to beginning This module manages up to 100 concurrent file handles with internal buffering. Testing The library includes comprehensive testing infrastructure using the test-drive framework: Test Coverage Mock-based testing : PATH manipulation replaces curl with controllable mock script Error condition testing : Network failures, authentication errors, HTTP error codes, malformed responses Edge case testing : Empty keys, very long keys, special characters, boundary conditions Uninitialized state testing : Separate executable ensures proper isolation Protocol testing : Both HTTP and HTTPS, various S3-compatible endpoints URI parsing tests : Complex URIs, edge cases in bucket/key extraction Running Tests # Run all tests with mock curl PATH = \"test/scripts: $PATH \" fpm test # Tests are defined in test/test_s3_http.f90 # Mock responses stored in test/data/responses/ Use Cases Scientific Data Access Access climate model output, observational data, and analysis results stored in S3: Read NetCDF files from ESGF data nodes Process CMIP6 climate model output Access NOAA, NASA, and other public scientific datasets Integrate with existing Fortran scientific workflows Public Bucket Integration The library excels at reading from public S3 buckets commonly used in scientific computing: NOAA Global Forecast System (GFS) data NASA Earth observation data CMIP6 climate model archives Genomics datasets (1000 Genomes, NIH) Limitations URL encoding : Special characters in S3 keys are currently untested; use alphanumeric keys with underscores for safety Authentication : Uses simplified credential checking; production write operations require AWS Signature v4 (planned) Binary data : Current implementation optimized for text; binary support exists but is less tested Dependencies : Requires system curl command to be available in PATH Parallel I/O : No built-in support for concurrent multi-threaded access Examples Example 1: Basic Object Download Download a text file from a public S3 bucket: program basic_download use s3_http implicit none type ( s3_config ) :: config character ( len = :), allocatable :: content logical :: success ! Configure for public NOAA bucket config % bucket = 'noaa-gfs-bdp-pds' config % region = 'us-east-1' config % endpoint = 's3.amazonaws.com' config % use_https = . true . call s3_init ( config ) ! Download README success = s3_get_object ( 'README.md' , content ) if ( success ) then print * , 'Downloaded ' , len ( content ), ' bytes' print * , content else print * , 'Download failed' end if end program basic_download Example 2: Check Object Existence Verify an object exists before attempting to download: program check_exists use s3_http implicit none type ( s3_config ) :: config logical :: exists config % bucket = 'my-bucket' config % use_https = . true . call s3_init ( config ) exists = s3_object_exists ( 'data/input.nc' ) if ( exists ) then print * , 'File exists, proceeding with download...' else print * , 'File not found, using default data' end if end program check_exists Example 3: Using Fortran I/O Interface Read an S3 object line by line like a regular file: program read_lines use s3_http use s3_io implicit none type ( s3_config ) :: config integer :: unit , iostat , line_count character ( len = 1024 ) :: line ! Initialize config % bucket = 'my-data-bucket' call s3_init ( config ) ! Open S3 object call s3_open ( unit , 'data/measurements.csv' , 'read' , iostat ) if ( iostat /= 0 ) stop 'Failed to open file' ! Read all lines line_count = 0 do call s3_read_line ( unit , line , iostat ) if ( iostat /= 0 ) exit line_count = line_count + 1 print * , 'Line ' , line_count , ': ' , trim ( line ) end do call s3_close ( unit , iostat ) print * , 'Read ' , line_count , ' lines' end program read_lines Example 4: URI-based Access Across Buckets Use s3:// URIs to seamlessly access multiple buckets: program uri_access use s3_http implicit none type ( s3_config ) :: config character ( len = :), allocatable :: content logical :: success ! Initialize with default bucket config % bucket = 'default-bucket' config % use_https = . true . call s3_init ( config ) ! Access different bucket via URI success = s3_get_uri ( 's3://other-bucket/path/to/data.txt' , content ) if ( success ) then print * , 'Content from other-bucket: ' , content end if ! Original bucket still accessible success = s3_get_object ( 'local-data.txt' , content ) end program uri_access Example 5: NetCDF Climate Data Download and process NetCDF files from ESGF climate data archives: program climate_data use s3_http use netcdf implicit none type ( s3_config ) :: config character ( len = :), allocatable :: nc_data character ( len =* ), parameter :: climate_uri = & 's3://esgf-world/CMIP6/CMIP/AWI/AWI-ESM-1-1-LR/piControl/r1i1p1f1/fx/areacella/gn/v20200212/' // & 'areacella_fx_AWI-ESM-1-1-LR_piControl_r1i1p1f1_gn.nc' logical :: success ! Configure for public ESGF bucket config % use_https = . true . call s3_init ( config ) ! Download NetCDF file success = s3_get_uri ( climate_uri , nc_data ) if ( success ) then ! Write to temp file and process with NetCDF library open ( 10 , file = '/tmp/climate.nc' , form = 'unformatted' , access = 'stream' ) write ( 10 ) nc_data close ( 10 ) ! Now use NetCDF library to read the file print * , 'Climate data downloaded, ready for processing' end if end program climate_data Example 6: Writing Data (with Authentication) Upload data to S3 (requires AWS credentials): program write_data use s3_http implicit none type ( s3_config ) :: config character ( len = :), allocatable :: data logical :: success ! Configure with credentials config % bucket = 'my-output-bucket' config % access_key = 'AKIAIOSFODNN7EXAMPLE' config % secret_key = 'wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY' config % use_https = . true . call s3_init ( config ) ! Create data data = 'simulation results: temp=25.3, pressure=1013.2' ! Upload to S3 success = s3_put_object ( 'results/output.txt' , data ) if ( success ) then print * , 'Data uploaded successfully' else print * , 'Upload failed' end if end program write_data Getting Started Clone the repository : bash\n   git clone https://github.com/pgierz/fortran-s3-accessor.git Build with FPM : bash\n   fpm build\n   fpm test  # Run tests Or build with CMake : bash\n   mkdir build && cd build\n   cmake .. -DCMAKE_BUILD_TYPE=Release\n   make -j Run examples : bash\n   fpm run test_simple              # Basic operations\n   fpm run --example s3_netcdf_example  # NetCDF example Integration To use in your project with FPM, add to fpm.toml : [dependencies] fortran-s3-accessor = { git = \"https://github.com/pgierz/fortran-s3-accessor.git\" } Then in your code: use s3_http ! For direct S3 operations use s3_io ! For Fortran I/O interface Developer Info Paul Gierz","tags":"home","url":"index.html"},{"title":"s3_file – fortran-s3-accessor ","text":"type, private :: s3_file Internal file handle type for managing S3 objects as file-like entities. This type maintains the state of an open S3 object, including its content buffer,\nread/write position, and mode. Used internally by the module. Components Type Visibility Attributes Name Initial logical, public :: is_open = .false. character(len=256), public :: key = '' character(len=:), public, allocatable :: buffer integer, public :: position = 1 logical, public :: is_write = .false. Source Code type :: s3_file logical :: is_open = . false . !< Whether this file handle is in use character ( len = 256 ) :: key = '' !< S3 object key character ( len = :), allocatable :: buffer !< Content buffer integer :: position = 1 !< Current read/write position logical :: is_write = . false . !< Write mode flag end type s3_file","tags":"","url":"type/s3_file.html"},{"title":"s3_config – fortran-s3-accessor ","text":"type, public :: s3_config S3 configuration type containing connection parameters and credentials. This type holds all configuration needed to connect to an S3-compatible\nobject storage service. For public buckets, credentials can be left empty. Example type ( s3_config ) :: config config % bucket = 'noaa-gfs-bdp-pds' config % region = 'us-east-1' config % endpoint = 's3.amazonaws.com' config % use_https = . true . config % access_key = '' ! Empty for public bucket config % secret_key = '' Components Type Visibility Attributes Name Initial character(len=256), public :: bucket = '' character(len=256), public :: region = 'us-east-1' character(len=256), public :: endpoint = 's3.amazonaws.com' character(len=256), public :: access_key = '' character(len=256), public :: secret_key = '' logical, public :: use_https = .true. Source Code type , public :: s3_config character ( len = 256 ) :: bucket = '' !< S3 bucket name character ( len = 256 ) :: region = 'us-east-1' !< AWS region (default: us-east-1) character ( len = 256 ) :: endpoint = 's3.amazonaws.com' !< S3 endpoint hostname character ( len = 256 ) :: access_key = '' !< AWS access key ID (optional for public buckets) character ( len = 256 ) :: secret_key = '' !< AWS secret access key (optional for public buckets) logical :: use_https = . true . !< Use HTTPS protocol (recommended) end type s3_config","tags":"","url":"type/s3_config.html"},{"title":"s3_open – fortran-s3-accessor","text":"public  subroutine s3_open(unit, key, mode, iostat) Open an S3 object for reading or writing. Opens an S3 object and returns a unit number for subsequent I/O operations.\nFor read mode, the object is downloaded immediately. For write mode, content\nis buffered in memory until s3_close() is called. @param[out] unit The allocated unit number (set to -1 on error)\n@param[in] key The S3 object key to open\n@param[in] mode Open mode: 'read'/'r' for reading, 'write'/'w' for writing\n@param[out] iostat Status code: 0 on success, -1 on error Example integer :: unit , iostat ! Open for reading call s3_open ( unit , 'data/input.txt' , 'read' , iostat ) if ( iostat == 0 ) then ! Read operations... call s3_close ( unit , iostat ) end if Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit character(len=*), intent(in) :: key character(len=*), intent(in) :: mode integer, intent(out) :: iostat Calls proc~~s3_open~~CallsGraph proc~s3_open s3_open proc~s3_get_object s3_get_object proc~s3_open->proc~s3_get_object Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine s3_open ( unit , key , mode , iostat ) integer , intent ( out ) :: unit character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ) :: mode integer , intent ( out ) :: iostat integer :: i character ( len = :), allocatable :: content iostat = 0 unit = - 1 ! Find available unit do i = 1 , MAX_FILES if (. not . files ( i )% is_open ) then unit = i exit end if end do if ( unit < 0 ) then iostat = - 1 return end if files ( unit )% key = key files ( unit )% is_open = . true . files ( unit )% position = 1 select case ( mode ) case ( 'read' , 'r' ) files ( unit )% is_write = . false . ! Download the file content if ( s3_get_object ( key , content )) then files ( unit )% buffer = content else iostat = - 1 files ( unit )% is_open = . false . end if case ( 'write' , 'w' ) files ( unit )% is_write = . true . files ( unit )% buffer = '' case default iostat = - 1 files ( unit )% is_open = . false . end select end subroutine s3_open","tags":"","url":"proc/s3_open.html"},{"title":"s3_close – fortran-s3-accessor","text":"public  subroutine s3_close(unit, iostat) Close an S3 file handle. Closes an open S3 file handle. For write mode, this uploads the buffered\ncontent to S3. The file handle is released and can be reused. @param[in] unit The unit number to close\n@param[out] iostat Status code: 0 on success, -1 on error Warning For write mode, upload errors will be reflected in iostat. Example call s3_close ( unit , iostat ) if ( iostat /= 0 ) then print * , 'Error closing file' end if Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(out) :: iostat Calls proc~~s3_close~~CallsGraph proc~s3_close s3_close proc~s3_put_object s3_put_object proc~s3_close->proc~s3_put_object Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine s3_close ( unit , iostat ) integer , intent ( in ) :: unit integer , intent ( out ) :: iostat logical :: success iostat = 0 if ( unit < 1 . or . unit > MAX_FILES ) then iostat = - 1 return end if if (. not . files ( unit )% is_open ) then iostat = - 1 return end if ! If writing, upload the buffer if ( files ( unit )% is_write . and . allocated ( files ( unit )% buffer )) then success = s3_put_object ( files ( unit )% key , files ( unit )% buffer ) if (. not . success ) iostat = - 1 end if ! Clean up files ( unit )% is_open = . false . files ( unit )% key = '' files ( unit )% position = 1 files ( unit )% is_write = . false . if ( allocated ( files ( unit )% buffer )) deallocate ( files ( unit )% buffer ) end subroutine s3_close","tags":"","url":"proc/s3_close.html"},{"title":"s3_read_line – fortran-s3-accessor","text":"public  subroutine s3_read_line(unit, line, iostat) Read a line from an open S3 file. Reads the next line from the file buffer. Lines are delimited by newline characters.\nThe file must be opened in read mode. @param[in] unit The unit number to read from\n@param[out] line The line content (truncated if longer than buffer)\n@param[out] iostat Status code: 0 on success, -1 on EOF or error Example character ( len = 1024 ) :: line integer :: iostat do call s3_read_line ( unit , line , iostat ) if ( iostat /= 0 ) exit print * , trim ( line ) end do Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit character(len=*), intent(out) :: line integer, intent(out) :: iostat Source Code subroutine s3_read_line ( unit , line , iostat ) integer , intent ( in ) :: unit character ( len =* ), intent ( out ) :: line integer , intent ( out ) :: iostat integer :: i , line_end , buffer_len iostat = 0 line = '' if ( unit < 1 . or . unit > MAX_FILES ) then iostat = - 1 return end if if (. not . files ( unit )% is_open . or . files ( unit )% is_write ) then iostat = - 1 return end if if (. not . allocated ( files ( unit )% buffer )) then iostat = - 1 return end if buffer_len = len ( files ( unit )% buffer ) ! Check if at end of file if ( files ( unit )% position > buffer_len ) then iostat = - 1 ! EOF return end if ! Find next newline line_end = 0 do i = files ( unit )% position , buffer_len if ( files ( unit )% buffer ( i : i ) == new_line ( '' )) then line_end = i - 1 exit end if end do ! If no newline found, read to end if ( line_end == 0 ) then line_end = buffer_len end if ! Extract line if ( line_end >= files ( unit )% position ) then line = files ( unit )% buffer ( files ( unit )% position : line_end ) files ( unit )% position = line_end + 2 ! Skip newline else iostat = - 1 end if end subroutine s3_read_line","tags":"","url":"proc/s3_read_line.html"},{"title":"s3_write_line – fortran-s3-accessor","text":"public  subroutine s3_write_line(unit, line, iostat) Write a line to an open S3 file. Appends a line to the file buffer. A newline character is automatically added.\nThe file must be opened in write mode. Content is uploaded when s3_close() is called. @param[in] unit The unit number to write to\n@param[in] line The line content to write\n@param[out] iostat Status code: 0 on success, -1 on error Example call s3_write_line ( unit , 'temperature,pressure' , iostat ) call s3_write_line ( unit , '25.3,1013.2' , iostat ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit character(len=*), intent(in) :: line integer, intent(out) :: iostat Source Code subroutine s3_write_line ( unit , line , iostat ) integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: line integer , intent ( out ) :: iostat character ( len = :), allocatable :: new_buffer iostat = 0 if ( unit < 1 . or . unit > MAX_FILES ) then iostat = - 1 return end if if (. not . files ( unit )% is_open . or . . not . files ( unit )% is_write ) then iostat = - 1 return end if ! Append line to buffer if (. not . allocated ( files ( unit )% buffer )) then files ( unit )% buffer = trim ( line ) // new_line ( '' ) else new_buffer = files ( unit )% buffer // trim ( line ) // new_line ( '' ) files ( unit )% buffer = new_buffer end if end subroutine s3_write_line","tags":"","url":"proc/s3_write_line.html"},{"title":"s3_rewind – fortran-s3-accessor","text":"public  subroutine s3_rewind(unit, iostat) Rewind an S3 file to the beginning. Resets the read position to the start of the file buffer. Only valid for read mode. @param[in] unit The unit number to rewind\n@param[out] iostat Status code: 0 on success, -1 on error Example ! Read file twice call s3_open ( unit , 'data/file.txt' , 'read' , iostat ) ! ... read operations ... call s3_rewind ( unit , iostat ) ! ... read again from start ... call s3_close ( unit , iostat ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(out) :: iostat Source Code subroutine s3_rewind ( unit , iostat ) integer , intent ( in ) :: unit integer , intent ( out ) :: iostat iostat = 0 if ( unit < 1 . or . unit > MAX_FILES ) then iostat = - 1 return end if if (. not . files ( unit )% is_open ) then iostat = - 1 return end if files ( unit )% position = 1 end subroutine s3_rewind","tags":"","url":"proc/s3_rewind.html"},{"title":"s3_get_object – fortran-s3-accessor","text":"public  function s3_get_object(key, content) result(success) Download an object from S3 and return its content. Downloads the specified object from S3 using an HTTP GET request via curl.\nThe content is returned as an allocatable string. Works with both public\nand authenticated buckets. @param[in] key The S3 object key (path within the bucket)\n@param[out] content The downloaded content as an allocatable string\n@return .true. if download succeeded, .false. on error Note The module must be initialized with s3_init() before calling this function. Warning Returns .false. if the module is not initialized or if the download fails. Example character ( len = :), allocatable :: content logical :: success success = s3_get_object ( 'data/input.txt' , content ) if ( success ) then print * , 'Downloaded: ' , len ( content ), ' bytes' print * , content else print * , 'Download failed' end if Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key character(len=:), intent(out), allocatable :: content Return Value logical Called by proc~~s3_get_object~~CalledByGraph proc~s3_get_object s3_get_object proc~s3_get_uri s3_get_uri proc~s3_get_uri->proc~s3_get_object proc~s3_open s3_open proc~s3_open->proc~s3_get_object Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function s3_get_object ( key , content ) result ( success ) character ( len =* ), intent ( in ) :: key character ( len = :), allocatable , intent ( out ) :: content logical :: success character ( len = 2048 ) :: url character ( len = 4096 ) :: cmd character ( len = 256 ) :: tmpfile integer :: unit , ios , filesize character ( len = 1 ) :: byte integer :: i success = . false . if (. not . initialized ) return ! Build URL if ( current_config % use_https ) then write ( url , '(A,A,A,A,A,A)' ) 'https://' , & trim ( current_config % bucket ), '.' , & trim ( current_config % endpoint ), '/' , & trim ( key ) else write ( url , '(A,A,A,A,A,A)' ) 'http://' , & trim ( current_config % bucket ), '.' , & trim ( current_config % endpoint ), '/' , & trim ( key ) end if ! Create temp file name write ( tmpfile , '(A,I0,A)' ) '/tmp/s3_get_' , getpid (), '.tmp' ! Build curl command write ( cmd , '(A,A,A,A,A)' ) 'curl -s -o ' , trim ( tmpfile ), ' \"' , trim ( url ), '\"' ! Execute curl call execute_command_line ( cmd , exitstat = ios ) if ( ios /= 0 ) return ! Read the downloaded file inquire ( file = tmpfile , size = filesize , iostat = ios ) if ( ios /= 0 ) return allocate ( character ( len = filesize ) :: content ) open ( newunit = unit , file = tmpfile , access = 'stream' , & form = 'unformatted' , status = 'old' , iostat = ios ) if ( ios /= 0 ) then deallocate ( content ) return end if do i = 1 , filesize read ( unit , iostat = ios ) byte if ( ios /= 0 ) exit content ( i : i ) = byte end do close ( unit ) ! Clean up temp file write ( cmd , '(A,A)' ) 'rm -f ' , trim ( tmpfile ) call execute_command_line ( cmd ) success = ( ios == 0 . and . index ( content , '<Error>' ) == 0 ) end function s3_get_object","tags":"","url":"proc/s3_get_object.html"},{"title":"s3_put_object – fortran-s3-accessor","text":"public  function s3_put_object(key, content) result(success) Upload an object to S3. Uploads the provided content to S3 at the specified key using an HTTP PUT request.\nThis operation requires AWS credentials to be configured in the s3_config. @param[in] key The S3 object key (path within the bucket) where content will be stored\n@param[in] content The content to upload as a string\n@return .true. if upload succeeded, .false. on error Note Requires AWS credentials (access_key and secret_key) to be set in configuration. Warning Returns .false. if credentials are missing or upload fails. Warning Current implementation uses simplified authentication; production use requires AWS Signature v4. Example type ( s3_config ) :: config logical :: success config % bucket = 'my-bucket' config % access_key = 'AKIAIOSFODNN7EXAMPLE' config % secret_key = 'wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY' call s3_init ( config ) success = s3_put_object ( 'results/output.txt' , 'Hello S3!' ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key character(len=*), intent(in) :: content Return Value logical Called by proc~~s3_put_object~~CalledByGraph proc~s3_put_object s3_put_object proc~s3_close s3_close proc~s3_close->proc~s3_put_object proc~s3_put_uri s3_put_uri proc~s3_put_uri->proc~s3_put_object Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function s3_put_object ( key , content ) result ( success ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ) :: content logical :: success character ( len = 2048 ) :: url character ( len = 4096 ) :: cmd character ( len = 256 ) :: tmpfile integer :: unit , ios success = . false . if (. not . initialized ) return ! For public buckets without auth, PUT won't work ! This is a simplified version - real implementation needs AWS signature if ( len_trim ( current_config % access_key ) == 0 ) then print * , 'Warning: PUT requires AWS credentials' return end if ! Build URL if ( current_config % use_https ) then write ( url , '(A,A,A,A,A,A)' ) 'https://' , & trim ( current_config % bucket ), '.' , & trim ( current_config % endpoint ), '/' , & trim ( key ) else write ( url , '(A,A,A,A,A,A)' ) 'http://' , & trim ( current_config % bucket ), '.' , & trim ( current_config % endpoint ), '/' , & trim ( key ) end if ! Create temp file with content write ( tmpfile , '(A,I0,A)' ) '/tmp/s3_put_' , getpid (), '.tmp' open ( newunit = unit , file = tmpfile , status = 'replace' , iostat = ios ) if ( ios /= 0 ) return write ( unit , '(A)' , iostat = ios ) trim ( content ) close ( unit ) ! Build curl command for PUT (simplified - needs AWS v4 signature in reality) write ( cmd , '(A,A,A,A,A)' ) 'curl -s -X PUT --data-binary @' , & trim ( tmpfile ), ' \"' , trim ( url ), '\"' ! Execute curl call execute_command_line ( cmd , exitstat = ios ) ! Clean up temp file write ( cmd , '(A,A)' ) 'rm -f ' , trim ( tmpfile ) call execute_command_line ( cmd ) success = ( ios == 0 ) end function s3_put_object","tags":"","url":"proc/s3_put_object.html"},{"title":"s3_object_exists – fortran-s3-accessor","text":"public  function s3_object_exists(key) result(exists) Check if an object exists in S3. Performs an HTTP HEAD request to check if an object exists without downloading it.\nThis is more efficient than attempting a GET request when you only need to verify existence. @param[in] key The S3 object key to check\n@return .true. if object exists, .false. if not found or on error Note The module must be initialized with s3_init() before calling this function. Example logical :: exists exists = s3_object_exists ( 'data/input.nc' ) if ( exists ) then print * , 'File found, proceeding with download' else print * , 'File not found, using defaults' end if Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Return Value logical Called by proc~~s3_object_exists~~CalledByGraph proc~s3_object_exists s3_object_exists proc~s3_exists_uri s3_exists_uri proc~s3_exists_uri->proc~s3_object_exists Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function s3_object_exists ( key ) result ( exists ) character ( len =* ), intent ( in ) :: key logical :: exists character ( len = 2048 ) :: url character ( len = 4096 ) :: cmd integer :: ios exists = . false . if (. not . initialized ) return ! Build URL if ( current_config % use_https ) then write ( url , '(A,A,A,A,A,A)' ) 'https://' , & trim ( current_config % bucket ), '.' , & trim ( current_config % endpoint ), '/' , & trim ( key ) else write ( url , '(A,A,A,A,A,A)' ) 'http://' , & trim ( current_config % bucket ), '.' , & trim ( current_config % endpoint ), '/' , & trim ( key ) end if ! Use curl HEAD request to check existence write ( cmd , '(A,A,A)' ) 'curl -s -I \"' , trim ( url ), '\" | grep \"HTTP\" | grep -q \"200 OK\"' call execute_command_line ( cmd , exitstat = ios ) exists = ( ios == 0 ) end function s3_object_exists","tags":"","url":"proc/s3_object_exists.html"},{"title":"s3_delete_object – fortran-s3-accessor","text":"public  function s3_delete_object(key) result(success) Delete an object from S3. Deletes the specified object from S3 using an HTTP DELETE request.\nThis operation requires AWS credentials to be configured. @param[in] key The S3 object key to delete\n@return .true. if deletion succeeded, .false. on error Note Requires AWS credentials (access_key and secret_key) to be set in configuration. Warning This operation is irreversible. Deleted objects cannot be recovered. Warning Returns .false. if credentials are missing or deletion fails. Example logical :: success success = s3_delete_object ( 'temp/scratch_data.txt' ) if ( success ) then print * , 'Object deleted successfully' else print * , 'Deletion failed' end if Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Return Value logical Called by proc~~s3_delete_object~~CalledByGraph proc~s3_delete_object s3_delete_object proc~s3_delete_uri s3_delete_uri proc~s3_delete_uri->proc~s3_delete_object Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function s3_delete_object ( key ) result ( success ) character ( len =* ), intent ( in ) :: key logical :: success character ( len = 2048 ) :: url character ( len = 4096 ) :: cmd integer :: ios success = . false . if (. not . initialized ) return ! For public buckets without auth, DELETE won't work if ( len_trim ( current_config % access_key ) == 0 ) then print * , 'Warning: DELETE requires AWS credentials' return end if ! Build URL if ( current_config % use_https ) then write ( url , '(A,A,A,A,A,A)' ) 'https://' , & trim ( current_config % bucket ), '.' , & trim ( current_config % endpoint ), '/' , & trim ( key ) else write ( url , '(A,A,A,A,A,A)' ) 'http://' , & trim ( current_config % bucket ), '.' , & trim ( current_config % endpoint ), '/' , & trim ( key ) end if ! Build curl command for DELETE write ( cmd , '(A,A,A)' ) 'curl -s -X DELETE \"' , trim ( url ), '\"' call execute_command_line ( cmd , exitstat = ios ) success = ( ios == 0 ) end function s3_delete_object","tags":"","url":"proc/s3_delete_object.html"},{"title":"getpid – fortran-s3-accessor","text":"private  function getpid() result(pid) Arguments None Return Value integer Source Code function getpid () result ( pid ) integer :: pid real :: rand_val pid = 1 ! Simplified - would use actual getpid() C function call random_number ( rand_val ) pid = abs ( int ( rand_val * 100000 )) end function getpid","tags":"","url":"proc/getpid.html"},{"title":"s3_get_uri – fortran-s3-accessor","text":"public  function s3_get_uri(uri, content) result(success) Download an object using an s3:// URI. Convenience function that accepts s3:// URIs and automatically extracts the bucket\nname and object key. If the bucket differs from the current configuration, it\ntemporarily switches to that bucket for the operation. @param[in] uri The s3:// URI (e.g., 's3://bucket-name/path/to/object')\n@param[out] content The downloaded content as an allocatable string\n@return .true. if download succeeded, .false. on error Example character ( len = :), allocatable :: content logical :: success ! Download from different bucket using URI success = s3_get_uri ( 's3://other-bucket/data/file.txt' , content ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: uri character(len=:), intent(out), allocatable :: content Return Value logical Calls proc~~s3_get_uri~~CallsGraph proc~s3_get_uri s3_get_uri proc~parse_s3_uri parse_s3_uri proc~s3_get_uri->proc~parse_s3_uri proc~s3_get_object s3_get_object proc~s3_get_uri->proc~s3_get_object proc~s3_init s3_init proc~s3_get_uri->proc~s3_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function s3_get_uri ( uri , content ) result ( success ) character ( len =* ), intent ( in ) :: uri character ( len = :), allocatable , intent ( out ) :: content logical :: success character ( len = :), allocatable :: bucket , key type ( s3_config ) :: temp_config logical :: uri_parsed success = . false . ! Try to parse as s3:// URI call parse_s3_uri ( uri , bucket , key , uri_parsed ) if (. not . uri_parsed ) then ! Not a s3:// URI, treat as regular key with current config success = s3_get_object ( uri , content ) return end if ! Use parsed bucket if different from current config if ( allocated ( bucket ) . and . len_trim ( bucket ) > 0 ) then temp_config = current_config temp_config % bucket = bucket call s3_init ( temp_config ) success = s3_get_object ( key , content ) ! Restore original config call s3_init ( current_config ) else success = s3_get_object ( key , content ) end if end function s3_get_uri","tags":"","url":"proc/s3_get_uri.html"},{"title":"s3_exists_uri – fortran-s3-accessor","text":"public  function s3_exists_uri(uri) result(exists) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: uri Return Value logical Calls proc~~s3_exists_uri~~CallsGraph proc~s3_exists_uri s3_exists_uri proc~parse_s3_uri parse_s3_uri proc~s3_exists_uri->proc~parse_s3_uri proc~s3_init s3_init proc~s3_exists_uri->proc~s3_init proc~s3_object_exists s3_object_exists proc~s3_exists_uri->proc~s3_object_exists Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function s3_exists_uri ( uri ) result ( exists ) character ( len =* ), intent ( in ) :: uri logical :: exists character ( len = :), allocatable :: bucket , key type ( s3_config ) :: temp_config logical :: uri_parsed exists = . false . ! Try to parse as s3:// URI call parse_s3_uri ( uri , bucket , key , uri_parsed ) if (. not . uri_parsed ) then ! Not a s3:// URI, treat as regular key exists = s3_object_exists ( uri ) return end if ! Use parsed bucket if different from current config if ( allocated ( bucket ) . and . len_trim ( bucket ) > 0 ) then temp_config = current_config temp_config % bucket = bucket call s3_init ( temp_config ) exists = s3_object_exists ( key ) ! Restore original config call s3_init ( current_config ) else exists = s3_object_exists ( key ) end if end function s3_exists_uri","tags":"","url":"proc/s3_exists_uri.html"},{"title":"s3_put_uri – fortran-s3-accessor","text":"public  function s3_put_uri(uri, content) result(success) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: uri character(len=*), intent(in) :: content Return Value logical Calls proc~~s3_put_uri~~CallsGraph proc~s3_put_uri s3_put_uri proc~parse_s3_uri parse_s3_uri proc~s3_put_uri->proc~parse_s3_uri proc~s3_init s3_init proc~s3_put_uri->proc~s3_init proc~s3_put_object s3_put_object proc~s3_put_uri->proc~s3_put_object Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function s3_put_uri ( uri , content ) result ( success ) character ( len =* ), intent ( in ) :: uri character ( len =* ), intent ( in ) :: content logical :: success character ( len = :), allocatable :: bucket , key type ( s3_config ) :: temp_config logical :: uri_parsed success = . false . ! Try to parse as s3:// URI call parse_s3_uri ( uri , bucket , key , uri_parsed ) if (. not . uri_parsed ) then ! Not a s3:// URI, treat as regular key success = s3_put_object ( uri , content ) return end if ! Use parsed bucket if different from current config if ( allocated ( bucket ) . and . len_trim ( bucket ) > 0 ) then temp_config = current_config temp_config % bucket = bucket call s3_init ( temp_config ) success = s3_put_object ( key , content ) ! Restore original config call s3_init ( current_config ) else success = s3_put_object ( key , content ) end if end function s3_put_uri","tags":"","url":"proc/s3_put_uri.html"},{"title":"s3_delete_uri – fortran-s3-accessor","text":"public  function s3_delete_uri(uri) result(success) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: uri Return Value logical Calls proc~~s3_delete_uri~~CallsGraph proc~s3_delete_uri s3_delete_uri proc~parse_s3_uri parse_s3_uri proc~s3_delete_uri->proc~parse_s3_uri proc~s3_delete_object s3_delete_object proc~s3_delete_uri->proc~s3_delete_object proc~s3_init s3_init proc~s3_delete_uri->proc~s3_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function s3_delete_uri ( uri ) result ( success ) character ( len =* ), intent ( in ) :: uri logical :: success character ( len = :), allocatable :: bucket , key type ( s3_config ) :: temp_config logical :: uri_parsed success = . false . ! Try to parse as s3:// URI call parse_s3_uri ( uri , bucket , key , uri_parsed ) if (. not . uri_parsed ) then ! Not a s3:// URI, treat as regular key success = s3_delete_object ( uri ) return end if ! Use parsed bucket if different from current config if ( allocated ( bucket ) . and . len_trim ( bucket ) > 0 ) then temp_config = current_config temp_config % bucket = bucket call s3_init ( temp_config ) success = s3_delete_object ( key ) ! Restore original config call s3_init ( current_config ) else success = s3_delete_object ( key ) end if end function s3_delete_uri","tags":"","url":"proc/s3_delete_uri.html"},{"title":"parse_s3_uri – fortran-s3-accessor","text":"private  subroutine parse_s3_uri(uri, bucket, key, success) Parse an s3:// URI into bucket name and object key components. Parses URIs of the format s3://bucket-name/path/to/object into\nseparate bucket and key strings for use with S3 operations. @param[in] uri The s3:// URI to parse\n@param[out] bucket The extracted bucket name (allocatable)\n@param[out] key The extracted object key/path (allocatable)\n@param[out] success .true. if URI was successfully parsed, .false. otherwise Examples ! Parse URI with bucket and key call parse_s3_uri ( 's3://my-bucket/data/file.txt' , bucket , key , success ) ! Result: bucket='my-bucket', key='data/file.txt' ! Parse URI with only bucket call parse_s3_uri ( 's3://my-bucket' , bucket , key , success ) ! Result: bucket='my-bucket', key='' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: uri character(len=:), intent(out), allocatable :: bucket character(len=:), intent(out), allocatable :: key logical, intent(out) :: success Called by proc~~parse_s3_uri~~CalledByGraph proc~parse_s3_uri parse_s3_uri proc~s3_delete_uri s3_delete_uri proc~s3_delete_uri->proc~parse_s3_uri proc~s3_exists_uri s3_exists_uri proc~s3_exists_uri->proc~parse_s3_uri proc~s3_get_uri s3_get_uri proc~s3_get_uri->proc~parse_s3_uri proc~s3_put_uri s3_put_uri proc~s3_put_uri->proc~parse_s3_uri Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine parse_s3_uri ( uri , bucket , key , success ) character ( len =* ), intent ( in ) :: uri character ( len = :), allocatable , intent ( out ) :: bucket character ( len = :), allocatable , intent ( out ) :: key logical , intent ( out ) :: success integer :: bucket_start , bucket_end , key_start success = . false . ! Check for s3:// prefix if ( len ( uri ) < 6 ) return if ( uri ( 1 : 5 ) /= 's3://' ) return ! Find bucket name (between s3:// and next /) bucket_start = 6 bucket_end = index ( uri ( bucket_start :), '/' ) + bucket_start - 2 if ( bucket_end < bucket_start ) then ! No key, just bucket bucket = uri ( bucket_start :) key = '' success = . true . return end if ! Extract bucket and key bucket = uri ( bucket_start : bucket_end ) key_start = bucket_end + 2 if ( key_start <= len ( uri )) then key = uri ( key_start :) else key = '' end if success = . true . end subroutine parse_s3_uri","tags":"","url":"proc/parse_s3_uri.html"},{"title":"s3_init – fortran-s3-accessor","text":"public  subroutine s3_init(config) Initialize the S3 HTTP module with configuration. This subroutine must be called before any S3 operations can be performed.\nIt stores the provided configuration for use by all subsequent operations. @param[in] config S3 configuration containing bucket, endpoint, and credentials Example type ( s3_config ) :: config config % bucket = 'my-bucket' config % region = 'us-east-1' config % use_https = . true . call s3_init ( config ) Arguments Type Intent Optional Attributes Name type( s3_config ), intent(in) :: config Called by proc~~s3_init~~CalledByGraph proc~s3_init s3_init proc~s3_delete_uri s3_delete_uri proc~s3_delete_uri->proc~s3_init proc~s3_exists_uri s3_exists_uri proc~s3_exists_uri->proc~s3_init proc~s3_get_uri s3_get_uri proc~s3_get_uri->proc~s3_init proc~s3_put_uri s3_put_uri proc~s3_put_uri->proc~s3_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine s3_init ( config ) type ( s3_config ), intent ( in ) :: config current_config = config initialized = . true . end subroutine s3_init","tags":"","url":"proc/s3_init.html"},{"title":"s3_io – fortran-s3-accessor","text":"High-level Fortran I/O interface for S3 operations. This module provides a familiar Fortran-style I/O interface for working with S3 objects.\nIt supports operations similar to standard Fortran file I/O: open, read, write, close, and rewind.\nThe module internally buffers content for efficient line-by-line operations. Features Familiar Fortran I/O patterns (open/read/write/close) Line-based text file operations Internal buffering for efficient I/O Support for up to 100 concurrent file handles Automatic upload on close for write operations Usage use s3_http use s3_io type ( s3_config ) :: config integer :: unit , iostat character ( len = 1024 ) :: line ! Initialize S3 config % bucket = 'my-bucket' call s3_init ( config ) ! Open and read call s3_open ( unit , 'data/input.txt' , 'read' , iostat ) call s3_read_line ( unit , line , iostat ) call s3_close ( unit , iostat ) Note This module depends on the s3_http module for underlying S3 operations. Uses s3_http module~~s3_io~~UsesGraph module~s3_io s3_io module~s3_http s3_http module~s3_io->module~s3_http Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_FILES = 100 type( s3_file ), private, save :: files (MAX_FILES) Derived Types type, private :: s3_file Internal file handle type for managing S3 objects as file-like entities. Read more… Components Type Visibility Attributes Name Initial logical, public :: is_open = .false. character(len=256), public :: key = '' character(len=:), public, allocatable :: buffer integer, public :: position = 1 logical, public :: is_write = .false. Subroutines public  subroutine s3_open (unit, key, mode, iostat) Open an S3 object for reading or writing. Read more… Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit character(len=*), intent(in) :: key character(len=*), intent(in) :: mode integer, intent(out) :: iostat public  subroutine s3_close (unit, iostat) Close an S3 file handle. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(out) :: iostat public  subroutine s3_read_line (unit, line, iostat) Read a line from an open S3 file. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit character(len=*), intent(out) :: line integer, intent(out) :: iostat public  subroutine s3_write_line (unit, line, iostat) Write a line to an open S3 file. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit character(len=*), intent(in) :: line integer, intent(out) :: iostat public  subroutine s3_rewind (unit, iostat) Rewind an S3 file to the beginning. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(out) :: iostat","tags":"","url":"module/s3_io.html"},{"title":"s3_http – fortran-s3-accessor","text":"Core S3 HTTP operations module providing direct access to S3-compatible object storage. This module provides low-level HTTP-based operations for interacting with S3-compatible\nobject storage services. It uses system curl commands to perform GET, PUT, DELETE, and\nHEAD HTTP operations. Features Direct S3 operations via curl HTTP requests Support for both authenticated and public bucket access URI-based operations with s3:// protocol support HTTP and HTTPS protocol support Configurable endpoints for S3-compatible services Usage use s3_http type ( s3_config ) :: config character ( len = :), allocatable :: content logical :: success ! Configure and initialize config % bucket = 'my-bucket' config % region = 'us-east-1' config % use_https = . true . call s3_init ( config ) ! Download object success = s3_get_object ( 'data/file.txt' , content ) Note This module requires the curl command to be available in the system PATH. Warning URL encoding of special characters in S3 keys is not currently supported. Used by module~~s3_http~~UsedByGraph module~s3_http s3_http module~s3_io s3_io module~s3_io->module~s3_http Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial type( s3_config ), private, save :: current_config logical, private, save :: initialized = .false. Derived Types type, public :: s3_config S3 configuration type containing connection parameters and credentials. Read more… Components Type Visibility Attributes Name Initial character(len=256), public :: bucket = '' character(len=256), public :: region = 'us-east-1' character(len=256), public :: endpoint = 's3.amazonaws.com' character(len=256), public :: access_key = '' character(len=256), public :: secret_key = '' logical, public :: use_https = .true. Functions public  function s3_get_object (key, content) result(success) Download an object from S3 and return its content. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key character(len=:), intent(out), allocatable :: content Return Value logical public  function s3_put_object (key, content) result(success) Upload an object to S3. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key character(len=*), intent(in) :: content Return Value logical public  function s3_object_exists (key) result(exists) Check if an object exists in S3. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Return Value logical public  function s3_delete_object (key) result(success) Delete an object from S3. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Return Value logical private  function getpid () result(pid) Arguments None Return Value integer public  function s3_get_uri (uri, content) result(success) Download an object using an s3:// URI. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: uri character(len=:), intent(out), allocatable :: content Return Value logical public  function s3_exists_uri (uri) result(exists) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: uri Return Value logical public  function s3_put_uri (uri, content) result(success) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: uri character(len=*), intent(in) :: content Return Value logical public  function s3_delete_uri (uri) result(success) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: uri Return Value logical Subroutines private  subroutine parse_s3_uri (uri, bucket, key, success) Parse an s3:// URI into bucket name and object key components. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: uri character(len=:), intent(out), allocatable :: bucket character(len=:), intent(out), allocatable :: key logical, intent(out) :: success public  subroutine s3_init (config) Initialize the S3 HTTP module with configuration. Read more… Arguments Type Intent Optional Attributes Name type( s3_config ), intent(in) :: config","tags":"","url":"module/s3_http.html"},{"title":"s3_io.f90 – fortran-s3-accessor","text":"This file depends on sourcefile~~s3_io.f90~~EfferentGraph sourcefile~s3_io.f90 s3_io.f90 sourcefile~s3_http.f90 s3_http.f90 sourcefile~s3_io.f90->sourcefile~s3_http.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> High-level Fortran I/O interface for S3 operations. !> !> This module provides a familiar Fortran-style I/O interface for working with S3 objects. !> It supports operations similar to standard Fortran file I/O: open, read, write, close, and rewind. !> The module internally buffers content for efficient line-by-line operations. !> !> ## Features !> !> - Familiar Fortran I/O patterns (open/read/write/close) !> - Line-based text file operations !> - Internal buffering for efficient I/O !> - Support for up to 100 concurrent file handles !> - Automatic upload on close for write operations !> !> ## Usage !> !> ```fortran !> use s3_http !> use s3_io !> type(s3_config) :: config !> integer :: unit, iostat !> character(len=1024) :: line !> !> ! Initialize S3 !> config%bucket = 'my-bucket' !> call s3_init(config) !> !> ! Open and read !> call s3_open(unit, 'data/input.txt', 'read', iostat) !> call s3_read_line(unit, line, iostat) !> call s3_close(unit, iostat) !> ``` !> !> @note This module depends on the s3_http module for underlying S3 operations. module s3_io use s3_http implicit none private integer , parameter :: MAX_FILES = 100 !< Maximum number of concurrent open files !> Internal file handle type for managing S3 objects as file-like entities. !> !> This type maintains the state of an open S3 object, including its content buffer, !> read/write position, and mode. Used internally by the module. type :: s3_file logical :: is_open = . false . !< Whether this file handle is in use character ( len = 256 ) :: key = '' !< S3 object key character ( len = :), allocatable :: buffer !< Content buffer integer :: position = 1 !< Current read/write position logical :: is_write = . false . !< Write mode flag end type s3_file type ( s3_file ), save :: files ( MAX_FILES ) public :: s3_open public :: s3_close public :: s3_read_line public :: s3_write_line public :: s3_rewind contains !> Open an S3 object for reading or writing. !> !> Opens an S3 object and returns a unit number for subsequent I/O operations. !> For read mode, the object is downloaded immediately. For write mode, content !> is buffered in memory until s3_close() is called. !> !> @param[out] unit The allocated unit number (set to -1 on error) !> @param[in] key The S3 object key to open !> @param[in] mode Open mode: 'read'/'r' for reading, 'write'/'w' for writing !> @param[out] iostat Status code: 0 on success, -1 on error !> !> ## Example !> !> ```fortran !> integer :: unit, iostat !> !> ! Open for reading !> call s3_open(unit, 'data/input.txt', 'read', iostat) !> if (iostat == 0) then !>     ! Read operations... !>     call s3_close(unit, iostat) !> end if !> ``` subroutine s3_open ( unit , key , mode , iostat ) integer , intent ( out ) :: unit character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ) :: mode integer , intent ( out ) :: iostat integer :: i character ( len = :), allocatable :: content iostat = 0 unit = - 1 ! Find available unit do i = 1 , MAX_FILES if (. not . files ( i )% is_open ) then unit = i exit end if end do if ( unit < 0 ) then iostat = - 1 return end if files ( unit )% key = key files ( unit )% is_open = . true . files ( unit )% position = 1 select case ( mode ) case ( 'read' , 'r' ) files ( unit )% is_write = . false . ! Download the file content if ( s3_get_object ( key , content )) then files ( unit )% buffer = content else iostat = - 1 files ( unit )% is_open = . false . end if case ( 'write' , 'w' ) files ( unit )% is_write = . true . files ( unit )% buffer = '' case default iostat = - 1 files ( unit )% is_open = . false . end select end subroutine s3_open !> Close an S3 file handle. !> !> Closes an open S3 file handle. For write mode, this uploads the buffered !> content to S3. The file handle is released and can be reused. !> !> @param[in] unit The unit number to close !> @param[out] iostat Status code: 0 on success, -1 on error !> !> @warning For write mode, upload errors will be reflected in iostat. !> !> ## Example !> !> ```fortran !> call s3_close(unit, iostat) !> if (iostat /= 0) then !>     print *, 'Error closing file' !> end if !> ``` subroutine s3_close ( unit , iostat ) integer , intent ( in ) :: unit integer , intent ( out ) :: iostat logical :: success iostat = 0 if ( unit < 1 . or . unit > MAX_FILES ) then iostat = - 1 return end if if (. not . files ( unit )% is_open ) then iostat = - 1 return end if ! If writing, upload the buffer if ( files ( unit )% is_write . and . allocated ( files ( unit )% buffer )) then success = s3_put_object ( files ( unit )% key , files ( unit )% buffer ) if (. not . success ) iostat = - 1 end if ! Clean up files ( unit )% is_open = . false . files ( unit )% key = '' files ( unit )% position = 1 files ( unit )% is_write = . false . if ( allocated ( files ( unit )% buffer )) deallocate ( files ( unit )% buffer ) end subroutine s3_close !> Read a line from an open S3 file. !> !> Reads the next line from the file buffer. Lines are delimited by newline characters. !> The file must be opened in read mode. !> !> @param[in] unit The unit number to read from !> @param[out] line The line content (truncated if longer than buffer) !> @param[out] iostat Status code: 0 on success, -1 on EOF or error !> !> ## Example !> !> ```fortran !> character(len=1024) :: line !> integer :: iostat !> !> do !>     call s3_read_line(unit, line, iostat) !>     if (iostat /= 0) exit !>     print *, trim(line) !> end do !> ``` subroutine s3_read_line ( unit , line , iostat ) integer , intent ( in ) :: unit character ( len =* ), intent ( out ) :: line integer , intent ( out ) :: iostat integer :: i , line_end , buffer_len iostat = 0 line = '' if ( unit < 1 . or . unit > MAX_FILES ) then iostat = - 1 return end if if (. not . files ( unit )% is_open . or . files ( unit )% is_write ) then iostat = - 1 return end if if (. not . allocated ( files ( unit )% buffer )) then iostat = - 1 return end if buffer_len = len ( files ( unit )% buffer ) ! Check if at end of file if ( files ( unit )% position > buffer_len ) then iostat = - 1 ! EOF return end if ! Find next newline line_end = 0 do i = files ( unit )% position , buffer_len if ( files ( unit )% buffer ( i : i ) == new_line ( '' )) then line_end = i - 1 exit end if end do ! If no newline found, read to end if ( line_end == 0 ) then line_end = buffer_len end if ! Extract line if ( line_end >= files ( unit )% position ) then line = files ( unit )% buffer ( files ( unit )% position : line_end ) files ( unit )% position = line_end + 2 ! Skip newline else iostat = - 1 end if end subroutine s3_read_line !> Write a line to an open S3 file. !> !> Appends a line to the file buffer. A newline character is automatically added. !> The file must be opened in write mode. Content is uploaded when s3_close() is called. !> !> @param[in] unit The unit number to write to !> @param[in] line The line content to write !> @param[out] iostat Status code: 0 on success, -1 on error !> !> ## Example !> !> ```fortran !> call s3_write_line(unit, 'temperature,pressure', iostat) !> call s3_write_line(unit, '25.3,1013.2', iostat) !> ``` subroutine s3_write_line ( unit , line , iostat ) integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: line integer , intent ( out ) :: iostat character ( len = :), allocatable :: new_buffer iostat = 0 if ( unit < 1 . or . unit > MAX_FILES ) then iostat = - 1 return end if if (. not . files ( unit )% is_open . or . . not . files ( unit )% is_write ) then iostat = - 1 return end if ! Append line to buffer if (. not . allocated ( files ( unit )% buffer )) then files ( unit )% buffer = trim ( line ) // new_line ( '' ) else new_buffer = files ( unit )% buffer // trim ( line ) // new_line ( '' ) files ( unit )% buffer = new_buffer end if end subroutine s3_write_line !> Rewind an S3 file to the beginning. !> !> Resets the read position to the start of the file buffer. Only valid for read mode. !> !> @param[in] unit The unit number to rewind !> @param[out] iostat Status code: 0 on success, -1 on error !> !> ## Example !> !> ```fortran !> ! Read file twice !> call s3_open(unit, 'data/file.txt', 'read', iostat) !> ! ... read operations ... !> call s3_rewind(unit, iostat) !> ! ... read again from start ... !> call s3_close(unit, iostat) !> ``` subroutine s3_rewind ( unit , iostat ) integer , intent ( in ) :: unit integer , intent ( out ) :: iostat iostat = 0 if ( unit < 1 . or . unit > MAX_FILES ) then iostat = - 1 return end if if (. not . files ( unit )% is_open ) then iostat = - 1 return end if files ( unit )% position = 1 end subroutine s3_rewind end module s3_io","tags":"","url":"sourcefile/s3_io.f90.html"},{"title":"s3_http.f90 – fortran-s3-accessor","text":"Files dependent on this one sourcefile~~s3_http.f90~~AfferentGraph sourcefile~s3_http.f90 s3_http.f90 sourcefile~s3_io.f90 s3_io.f90 sourcefile~s3_io.f90->sourcefile~s3_http.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Core S3 HTTP operations module providing direct access to S3-compatible object storage. !> !> This module provides low-level HTTP-based operations for interacting with S3-compatible !> object storage services. It uses system curl commands to perform GET, PUT, DELETE, and !> HEAD HTTP operations. !> !> ## Features !> !> - Direct S3 operations via curl HTTP requests !> - Support for both authenticated and public bucket access !> - URI-based operations with s3:// protocol support !> - HTTP and HTTPS protocol support !> - Configurable endpoints for S3-compatible services !> !> ## Usage !> !> ```fortran !> use s3_http !> type(s3_config) :: config !> character(len=:), allocatable :: content !> logical :: success !> !> ! Configure and initialize !> config%bucket = 'my-bucket' !> config%region = 'us-east-1' !> config%use_https = .true. !> call s3_init(config) !> !> ! Download object !> success = s3_get_object('data/file.txt', content) !> ``` !> !> @note This module requires the `curl` command to be available in the system PATH. !> @warning URL encoding of special characters in S3 keys is not currently supported. module s3_http implicit none private !> S3 configuration type containing connection parameters and credentials. !> !> This type holds all configuration needed to connect to an S3-compatible !> object storage service. For public buckets, credentials can be left empty. !> !> ## Example !> !> ```fortran !> type(s3_config) :: config !> config%bucket = 'noaa-gfs-bdp-pds' !> config%region = 'us-east-1' !> config%endpoint = 's3.amazonaws.com' !> config%use_https = .true. !> config%access_key = ''  ! Empty for public bucket !> config%secret_key = '' !> ``` type , public :: s3_config character ( len = 256 ) :: bucket = '' !< S3 bucket name character ( len = 256 ) :: region = 'us-east-1' !< AWS region (default: us-east-1) character ( len = 256 ) :: endpoint = 's3.amazonaws.com' !< S3 endpoint hostname character ( len = 256 ) :: access_key = '' !< AWS access key ID (optional for public buckets) character ( len = 256 ) :: secret_key = '' !< AWS secret access key (optional for public buckets) logical :: use_https = . true . !< Use HTTPS protocol (recommended) end type s3_config ! Module variables type ( s3_config ), save :: current_config logical , save :: initialized = . false . ! Public procedures public :: s3_init public :: s3_get_object public :: s3_put_object public :: s3_object_exists public :: s3_delete_object ! s3:// URI functions public :: s3_get_uri public :: s3_put_uri public :: s3_exists_uri public :: s3_delete_uri contains !> Parse an s3:// URI into bucket name and object key components. !> !> Parses URIs of the format `s3://bucket-name/path/to/object` into !> separate bucket and key strings for use with S3 operations. !> !> @param[in] uri The s3:// URI to parse !> @param[out] bucket The extracted bucket name (allocatable) !> @param[out] key The extracted object key/path (allocatable) !> @param[out] success .true. if URI was successfully parsed, .false. otherwise !> !> ## Examples !> !> ```fortran !> ! Parse URI with bucket and key !> call parse_s3_uri('s3://my-bucket/data/file.txt', bucket, key, success) !> ! Result: bucket='my-bucket', key='data/file.txt' !> !> ! Parse URI with only bucket !> call parse_s3_uri('s3://my-bucket', bucket, key, success) !> ! Result: bucket='my-bucket', key='' !> ``` subroutine parse_s3_uri ( uri , bucket , key , success ) character ( len =* ), intent ( in ) :: uri character ( len = :), allocatable , intent ( out ) :: bucket character ( len = :), allocatable , intent ( out ) :: key logical , intent ( out ) :: success integer :: bucket_start , bucket_end , key_start success = . false . ! Check for s3:// prefix if ( len ( uri ) < 6 ) return if ( uri ( 1 : 5 ) /= 's3://' ) return ! Find bucket name (between s3:// and next /) bucket_start = 6 bucket_end = index ( uri ( bucket_start :), '/' ) + bucket_start - 2 if ( bucket_end < bucket_start ) then ! No key, just bucket bucket = uri ( bucket_start :) key = '' success = . true . return end if ! Extract bucket and key bucket = uri ( bucket_start : bucket_end ) key_start = bucket_end + 2 if ( key_start <= len ( uri )) then key = uri ( key_start :) else key = '' end if success = . true . end subroutine parse_s3_uri !> Initialize the S3 HTTP module with configuration. !> !> This subroutine must be called before any S3 operations can be performed. !> It stores the provided configuration for use by all subsequent operations. !> !> @param[in] config S3 configuration containing bucket, endpoint, and credentials !> !> ## Example !> !> ```fortran !> type(s3_config) :: config !> config%bucket = 'my-bucket' !> config%region = 'us-east-1' !> config%use_https = .true. !> call s3_init(config) !> ``` subroutine s3_init ( config ) type ( s3_config ), intent ( in ) :: config current_config = config initialized = . true . end subroutine s3_init !> Download an object from S3 and return its content. !> !> Downloads the specified object from S3 using an HTTP GET request via curl. !> The content is returned as an allocatable string. Works with both public !> and authenticated buckets. !> !> @param[in] key The S3 object key (path within the bucket) !> @param[out] content The downloaded content as an allocatable string !> @return .true. if download succeeded, .false. on error !> !> @note The module must be initialized with s3_init() before calling this function. !> @warning Returns .false. if the module is not initialized or if the download fails. !> !> ## Example !> !> ```fortran !> character(len=:), allocatable :: content !> logical :: success !> !> success = s3_get_object('data/input.txt', content) !> if (success) then !>     print *, 'Downloaded: ', len(content), ' bytes' !>     print *, content !> else !>     print *, 'Download failed' !> end if !> ``` function s3_get_object ( key , content ) result ( success ) character ( len =* ), intent ( in ) :: key character ( len = :), allocatable , intent ( out ) :: content logical :: success character ( len = 2048 ) :: url character ( len = 4096 ) :: cmd character ( len = 256 ) :: tmpfile integer :: unit , ios , filesize character ( len = 1 ) :: byte integer :: i success = . false . if (. not . initialized ) return ! Build URL if ( current_config % use_https ) then write ( url , '(A,A,A,A,A,A)' ) 'https://' , & trim ( current_config % bucket ), '.' , & trim ( current_config % endpoint ), '/' , & trim ( key ) else write ( url , '(A,A,A,A,A,A)' ) 'http://' , & trim ( current_config % bucket ), '.' , & trim ( current_config % endpoint ), '/' , & trim ( key ) end if ! Create temp file name write ( tmpfile , '(A,I0,A)' ) '/tmp/s3_get_' , getpid (), '.tmp' ! Build curl command write ( cmd , '(A,A,A,A,A)' ) 'curl -s -o ' , trim ( tmpfile ), ' \"' , trim ( url ), '\"' ! Execute curl call execute_command_line ( cmd , exitstat = ios ) if ( ios /= 0 ) return ! Read the downloaded file inquire ( file = tmpfile , size = filesize , iostat = ios ) if ( ios /= 0 ) return allocate ( character ( len = filesize ) :: content ) open ( newunit = unit , file = tmpfile , access = 'stream' , & form = 'unformatted' , status = 'old' , iostat = ios ) if ( ios /= 0 ) then deallocate ( content ) return end if do i = 1 , filesize read ( unit , iostat = ios ) byte if ( ios /= 0 ) exit content ( i : i ) = byte end do close ( unit ) ! Clean up temp file write ( cmd , '(A,A)' ) 'rm -f ' , trim ( tmpfile ) call execute_command_line ( cmd ) success = ( ios == 0 . and . index ( content , '<Error>' ) == 0 ) end function s3_get_object !> Upload an object to S3. !> !> Uploads the provided content to S3 at the specified key using an HTTP PUT request. !> This operation requires AWS credentials to be configured in the s3_config. !> !> @param[in] key The S3 object key (path within the bucket) where content will be stored !> @param[in] content The content to upload as a string !> @return .true. if upload succeeded, .false. on error !> !> @note Requires AWS credentials (access_key and secret_key) to be set in configuration. !> @warning Returns .false. if credentials are missing or upload fails. !> @warning Current implementation uses simplified authentication; production use requires AWS Signature v4. !> !> ## Example !> !> ```fortran !> type(s3_config) :: config !> logical :: success !> !> config%bucket = 'my-bucket' !> config%access_key = 'AKIAIOSFODNN7EXAMPLE' !> config%secret_key = 'wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY' !> call s3_init(config) !> !> success = s3_put_object('results/output.txt', 'Hello S3!') !> ``` function s3_put_object ( key , content ) result ( success ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ) :: content logical :: success character ( len = 2048 ) :: url character ( len = 4096 ) :: cmd character ( len = 256 ) :: tmpfile integer :: unit , ios success = . false . if (. not . initialized ) return ! For public buckets without auth, PUT won't work ! This is a simplified version - real implementation needs AWS signature if ( len_trim ( current_config % access_key ) == 0 ) then print * , 'Warning: PUT requires AWS credentials' return end if ! Build URL if ( current_config % use_https ) then write ( url , '(A,A,A,A,A,A)' ) 'https://' , & trim ( current_config % bucket ), '.' , & trim ( current_config % endpoint ), '/' , & trim ( key ) else write ( url , '(A,A,A,A,A,A)' ) 'http://' , & trim ( current_config % bucket ), '.' , & trim ( current_config % endpoint ), '/' , & trim ( key ) end if ! Create temp file with content write ( tmpfile , '(A,I0,A)' ) '/tmp/s3_put_' , getpid (), '.tmp' open ( newunit = unit , file = tmpfile , status = 'replace' , iostat = ios ) if ( ios /= 0 ) return write ( unit , '(A)' , iostat = ios ) trim ( content ) close ( unit ) ! Build curl command for PUT (simplified - needs AWS v4 signature in reality) write ( cmd , '(A,A,A,A,A)' ) 'curl -s -X PUT --data-binary @' , & trim ( tmpfile ), ' \"' , trim ( url ), '\"' ! Execute curl call execute_command_line ( cmd , exitstat = ios ) ! Clean up temp file write ( cmd , '(A,A)' ) 'rm -f ' , trim ( tmpfile ) call execute_command_line ( cmd ) success = ( ios == 0 ) end function s3_put_object !> Check if an object exists in S3. !> !> Performs an HTTP HEAD request to check if an object exists without downloading it. !> This is more efficient than attempting a GET request when you only need to verify existence. !> !> @param[in] key The S3 object key to check !> @return .true. if object exists, .false. if not found or on error !> !> @note The module must be initialized with s3_init() before calling this function. !> !> ## Example !> !> ```fortran !> logical :: exists !> !> exists = s3_object_exists('data/input.nc') !> if (exists) then !>     print *, 'File found, proceeding with download' !> else !>     print *, 'File not found, using defaults' !> end if !> ``` function s3_object_exists ( key ) result ( exists ) character ( len =* ), intent ( in ) :: key logical :: exists character ( len = 2048 ) :: url character ( len = 4096 ) :: cmd integer :: ios exists = . false . if (. not . initialized ) return ! Build URL if ( current_config % use_https ) then write ( url , '(A,A,A,A,A,A)' ) 'https://' , & trim ( current_config % bucket ), '.' , & trim ( current_config % endpoint ), '/' , & trim ( key ) else write ( url , '(A,A,A,A,A,A)' ) 'http://' , & trim ( current_config % bucket ), '.' , & trim ( current_config % endpoint ), '/' , & trim ( key ) end if ! Use curl HEAD request to check existence write ( cmd , '(A,A,A)' ) 'curl -s -I \"' , trim ( url ), '\" | grep \"HTTP\" | grep -q \"200 OK\"' call execute_command_line ( cmd , exitstat = ios ) exists = ( ios == 0 ) end function s3_object_exists !> Delete an object from S3. !> !> Deletes the specified object from S3 using an HTTP DELETE request. !> This operation requires AWS credentials to be configured. !> !> @param[in] key The S3 object key to delete !> @return .true. if deletion succeeded, .false. on error !> !> @note Requires AWS credentials (access_key and secret_key) to be set in configuration. !> @warning This operation is irreversible. Deleted objects cannot be recovered. !> @warning Returns .false. if credentials are missing or deletion fails. !> !> ## Example !> !> ```fortran !> logical :: success !> !> success = s3_delete_object('temp/scratch_data.txt') !> if (success) then !>     print *, 'Object deleted successfully' !> else !>     print *, 'Deletion failed' !> end if !> ``` function s3_delete_object ( key ) result ( success ) character ( len =* ), intent ( in ) :: key logical :: success character ( len = 2048 ) :: url character ( len = 4096 ) :: cmd integer :: ios success = . false . if (. not . initialized ) return ! For public buckets without auth, DELETE won't work if ( len_trim ( current_config % access_key ) == 0 ) then print * , 'Warning: DELETE requires AWS credentials' return end if ! Build URL if ( current_config % use_https ) then write ( url , '(A,A,A,A,A,A)' ) 'https://' , & trim ( current_config % bucket ), '.' , & trim ( current_config % endpoint ), '/' , & trim ( key ) else write ( url , '(A,A,A,A,A,A)' ) 'http://' , & trim ( current_config % bucket ), '.' , & trim ( current_config % endpoint ), '/' , & trim ( key ) end if ! Build curl command for DELETE write ( cmd , '(A,A,A)' ) 'curl -s -X DELETE \"' , trim ( url ), '\"' call execute_command_line ( cmd , exitstat = ios ) success = ( ios == 0 ) end function s3_delete_object ! Helper to get process ID function getpid () result ( pid ) integer :: pid real :: rand_val pid = 1 ! Simplified - would use actual getpid() C function call random_number ( rand_val ) pid = abs ( int ( rand_val * 100000 )) end function getpid !> Download an object using an s3:// URI. !> !> Convenience function that accepts s3:// URIs and automatically extracts the bucket !> name and object key. If the bucket differs from the current configuration, it !> temporarily switches to that bucket for the operation. !> !> @param[in] uri The s3:// URI (e.g., 's3://bucket-name/path/to/object') !> @param[out] content The downloaded content as an allocatable string !> @return .true. if download succeeded, .false. on error !> !> ## Example !> !> ```fortran !> character(len=:), allocatable :: content !> logical :: success !> !> ! Download from different bucket using URI !> success = s3_get_uri('s3://other-bucket/data/file.txt', content) !> ``` function s3_get_uri ( uri , content ) result ( success ) character ( len =* ), intent ( in ) :: uri character ( len = :), allocatable , intent ( out ) :: content logical :: success character ( len = :), allocatable :: bucket , key type ( s3_config ) :: temp_config logical :: uri_parsed success = . false . ! Try to parse as s3:// URI call parse_s3_uri ( uri , bucket , key , uri_parsed ) if (. not . uri_parsed ) then ! Not a s3:// URI, treat as regular key with current config success = s3_get_object ( uri , content ) return end if ! Use parsed bucket if different from current config if ( allocated ( bucket ) . and . len_trim ( bucket ) > 0 ) then temp_config = current_config temp_config % bucket = bucket call s3_init ( temp_config ) success = s3_get_object ( key , content ) ! Restore original config call s3_init ( current_config ) else success = s3_get_object ( key , content ) end if end function s3_get_uri ! Check if object exists using s3:// URI function s3_exists_uri ( uri ) result ( exists ) character ( len =* ), intent ( in ) :: uri logical :: exists character ( len = :), allocatable :: bucket , key type ( s3_config ) :: temp_config logical :: uri_parsed exists = . false . ! Try to parse as s3:// URI call parse_s3_uri ( uri , bucket , key , uri_parsed ) if (. not . uri_parsed ) then ! Not a s3:// URI, treat as regular key exists = s3_object_exists ( uri ) return end if ! Use parsed bucket if different from current config if ( allocated ( bucket ) . and . len_trim ( bucket ) > 0 ) then temp_config = current_config temp_config % bucket = bucket call s3_init ( temp_config ) exists = s3_object_exists ( key ) ! Restore original config call s3_init ( current_config ) else exists = s3_object_exists ( key ) end if end function s3_exists_uri ! Put an object using s3:// URI function s3_put_uri ( uri , content ) result ( success ) character ( len =* ), intent ( in ) :: uri character ( len =* ), intent ( in ) :: content logical :: success character ( len = :), allocatable :: bucket , key type ( s3_config ) :: temp_config logical :: uri_parsed success = . false . ! Try to parse as s3:// URI call parse_s3_uri ( uri , bucket , key , uri_parsed ) if (. not . uri_parsed ) then ! Not a s3:// URI, treat as regular key success = s3_put_object ( uri , content ) return end if ! Use parsed bucket if different from current config if ( allocated ( bucket ) . and . len_trim ( bucket ) > 0 ) then temp_config = current_config temp_config % bucket = bucket call s3_init ( temp_config ) success = s3_put_object ( key , content ) ! Restore original config call s3_init ( current_config ) else success = s3_put_object ( key , content ) end if end function s3_put_uri ! Delete an object using s3:// URI function s3_delete_uri ( uri ) result ( success ) character ( len =* ), intent ( in ) :: uri logical :: success character ( len = :), allocatable :: bucket , key type ( s3_config ) :: temp_config logical :: uri_parsed success = . false . ! Try to parse as s3:// URI call parse_s3_uri ( uri , bucket , key , uri_parsed ) if (. not . uri_parsed ) then ! Not a s3:// URI, treat as regular key success = s3_delete_object ( uri ) return end if ! Use parsed bucket if different from current config if ( allocated ( bucket ) . and . len_trim ( bucket ) > 0 ) then temp_config = current_config temp_config % bucket = bucket call s3_init ( temp_config ) success = s3_delete_object ( key ) ! Restore original config call s3_init ( current_config ) else success = s3_delete_object ( key ) end if end function s3_delete_uri end module s3_http","tags":"","url":"sourcefile/s3_http.f90.html"}]}